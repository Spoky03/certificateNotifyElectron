import { app, BrowserWindow, ipcMain, protocol, IpcMain } from "electron";
import { exec, spawn } from "child_process";
import axios from "axios";
import SimpleElectronStore from "./storage";
import path from "path";
import fs from "fs";
import { opensslPath } from "./lib/pathUtils";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 1000,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
    autoHideMenuBar: true,
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

app.on("ready", () => createWindow());

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
// Function to set the OpenSSL path based on the platform

ipcMain.handle("request", async (_, axios_request) => {
  const result = await axios(axios_request);
  return { data: result.data, status: result.status };
});
//get user email from os store
ipcMain.handle("get-local-storage", async (_, key) => {
  const store = new SimpleElectronStore();
  return store.get(key);
});
//set user email to os store
ipcMain.handle("set-local-storage", async (_, key, value) => {
  const store = new SimpleElectronStore();
  store.set(key, value);
  // save
  store.save();
  return value;
});
// Function to fetch certificates using PowerShell
ipcMain.handle("get-certificates", async () => {
  return new Promise((resolve, reject) => {
    exec(
      'powershell "Get-ChildItem -Path Cert:\\LocalMachine\\My, Cert:\\LocalMachine\\CA, Cert:\\LocalMachine\\Root | Format-List"',
      (error, stdout, stderr) => {
        if (error) {
          reject(`Error: ${error.message}`);
        } else if (stderr) {
          reject(`stderr: ${stderr}`);
        } else {
          resolve(stdout);
        }
      }
    );
  });
});
// ipcMain.handle("get-remote-certificates", async (_, command) => {
//   return new Promise((resolve, reject) => {

//     exec(
//       `"${opensslPath}" ${command}`,
//       { maxBuffer: 1024 * 1024 },
//       (error, stdout, stderr) => {
//         if (error) {
//           console.error(`Error executing command: ${error.message}`);
//           reject(`Error: ${error.message}`);
//         } else if (stderr) {
//           console.error(`stderr: ${stderr}`);
//           reject(`stderr: ${stderr}`);
//         } else {
//           console.log(`Command output: ${stdout}`);
//           resolve(stdout);
//         }
//       }
//     );
//   });
// });
ipcMain.handle("get-remote-certificates", async (_, command) => {
  return new Promise((resolve, reject) => {
    const child = spawn('openssl', [
      "s_client",
      "-connect",
      `${command}:443`,
      "-servername",
      `${command}`,
      "-showcerts",
    ]);

    let stdout = "";
    let stderr = "";

    child.stdout.on("data", (data) => {
      stdout += data.toString();
    });

    child.stderr.on("data", (data) => {
      stderr += data.toString();
    });

    // Once connected, send 'QUIT' to terminate the session
    child.stdin.write("QUIT\n");

    // Close the stdin stream (signals no more input)
    child.stdin.end();

    child.on("close", (code) => {
      if (code !== 0) {
        console.error(`Command exited with code ${code}`);
        reject(`Command exited with code ${code}: ${stderr}`);
      } else {
        console.log(`Command output: ${stdout}`);
        resolve(stdout);
      }
    });

    child.on("error", (error) => {
      console.error(`Error executing command: ${error.message}`);
      reject(`Error: ${error.message}`);
    });
  });
});
ipcMain.handle("getProtectedData", async (event, token) => {
  try {
    const response = await axios.get("http://localhost:3001/protected", {
      headers: { Authorization: `Bearer ${token}` },
    });
    return response.data;
  } catch (error) {
    console.error("Error fetching protected data:", error);
    throw error;
  }
});
